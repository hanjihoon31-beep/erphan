// server/routes/dailyInventoryRouter.js import express from "express"; import { verifyToken, verifyAdmin } from "../middleware/authMiddleware.js"; import DailyInventory from "../models/DailyInventory.js"; import DailyInventoryTemplate from "../models/DailyInventoryTemplate.js"; import Store from "../models/Store.js"; import Product from "../models/Product.js"; const router = express.Router(); // ==================== 일일 재고 템플릿 관리 (관리자용) ==================== // 매장별 재고 템플릿 조회 router.get("/templates/:storeId", verifyToken, async (req, res) => { try { const templates = await DailyInventoryTemplate.find({ store: req.params.storeId, isActive: true }) .populate("product", "productName unit category storageType") .populate("createdBy", "name email") .sort({ displayOrder: 1, createdAt: 1 }); res.json(templates); } catch (error) { console.error("템플릿 조회 오류:", error); res.status(500).json({ message: "템플릿 조회 실패" }); } }); // 재고 템플릿 생성 (관리자 전용) router.post("/templates", verifyToken, verifyAdmin, async (req, res) => { try { const { storeId, productId, displayOrder } = req.body; const existing = await DailyInventoryTemplate.findOne({ store: storeId, product: productId }); if (existing) { return res.status(400).json({ message: "이미 등록된 제품입니다." }); } const template = await DailyInventoryTemplate.create({ store: storeId, product: productId, displayOrder: displayOrder || 0, createdBy: req.user._id }); const populated = await DailyInventoryTemplate.findById(template._id) .populate("product", "productName unit category") .populate("store", "storeNumber storeName"); res.status(201).json({ success: true, template: populated }); } catch (error) { console.error("템플릿 생성 오류:", error); res.status(500).json({ message: "템플릿 생성 실패" }); } }); // 재고 템플릿 일괄 생성 (관리자 전용) router.post("/templates/bulk", verifyToken, verifyAdmin, async (req, res) => { try { const { storeId, productIds } = req.body; if (!Array.isArray(productIds) || productIds.length === 0) { return res.status(400).json({ message: "제품 목록이 필요합니다." }); } const templates = []; for (let i = 0; i < productIds.length; i++) { const existing = await DailyInventoryTemplate.findOne({ store: storeId, product: productIds[i] }); if (!existing) { templates.push({ store: storeId, product: productIds[i], displayOrder: i, createdBy: req.user._id }); } } if (templates.length > 0) { await DailyInventoryTemplate.insertMany(templates); } res.json({ success: true, message: `${templates.length}개 템플릿이 생성되었습니다.` }); } catch (error) { console.error("템플릿 일괄 생성 오류:", error); res.status(500).json({ message: "템플릿 일괄 생성 실패" }); } }); // 재고 템플릿 삭제 router.delete("/templates/:id", verifyToken, verifyAdmin, async (req, res) => { try { await DailyInventoryTemplate.findByIdAndDelete(req.params.id); res.json({ success: true, message: "템플릿이 삭제되었습니다." }); } catch (error) { console.error("템플릿 삭제 오류:", error); res.status(500).json({ message: "템플릿 삭제 실패" }); } }); // ==================== 일일 재고 생성 (자동/수동) ==================== router.post("/generate", verifyToken, async (req, res) => { try { const { storeId, date } = req.body; const targetDate = new Date(date); targetDate.setHours(0, 0, 0, 0); const existingCount = await DailyInventory.countDocuments({ store: storeId, date: targetDate }); if (existingCount > 0) { return res.status(400).json({ message: "이미 생성된 재고 서식입니다." }); } const templates = await DailyInventoryTemplate.find({ store: storeId, isActive: true }).sort({ displayOrder: 1 }); if (templates.length === 0) { return res.status(400).json({ message: "재고 템플릿이 설정되지 않았습니다." }); } const previousDate = new Date(targetDate); previousDate.setDate(previousDate.getDate() - 1); const previousInventories = await DailyInventory.find({ store: storeId, date: previousDate }); const previousStockMap = {}; previousInventories.forEach(inv => { previousStockMap[inv.product.toString()] = inv.closingStock || 0; }); const dailyInventories = templates.map(template => ({ store: storeId, product: template.product, date: targetDate, previousClosingStock: previousStockMap[template.product.toString()] || 0, status: "대기" })); await DailyInventory.insertMany(dailyInventories); res.json({ success: true, message: `${dailyInventories.length}개 재고 항목이 생성되었습니다.`, count: dailyInventories.length }); } catch (error) { console.error("재고 서식 생성 오류:", error); res.status(500).json({ message: "재고 서식 생성 실패" }); } }); // ==================== 일일 재고 조회 ==================== router.get("/:storeId/:date", verifyToken, async (req, res) => { try { const { storeId, date } = req.params; const targetDate = new Date(date); targetDate.setHours(0, 0, 0, 0); const dailyInventories = await DailyInventory.find({ store: storeId, date: targetDate }) .populate("product", "productName unit category storageType") .populate("submittedBy", "name email") .populate("approvedBy", "name email") .sort({ createdAt: 1 }); res.json(dailyInventories); } catch (error) { console.error("일일 재고 조회 오류:", error); res.status(500).json({ message: "일일 재고 조회 실패" }); } }); // 승인 대기 중인 재고 목록 조회 (관리자용) router.get("/pending/all", verifyToken, verifyAdmin, async (req, res) => { try { const pendingInventories = await DailyInventory.find({ status: "승인요청" }) .populate("store", "storeNumber storeName") .populate("product", "productName unit") .populate("submittedBy", "name email") .sort({ date: -1, submittedAt: -1 }); res.json(pendingInventories); } catch (error) { console.error("대기 목록 조회 오류:", error); res.status(500).json({ message: "대기 목록 조회 실패" }); } }); // ==================== 일일 재고 수정 ==================== router.put("/:id", verifyToken, async (req, res) => { try { const { morningStock, closingStock, inboundQuantity, outboundQuantity, discrepancyReason, notes } = req.body; const dailyInv = await DailyInventory.findById(req.params.id); if (!dailyInv) { return res.status(404).json({ message: "재고 항목을 찾을 수 없습니다." }); } let discrepancy = 0; if (morningStock !== undefined && dailyInv.previousClosingStock !== undefined) { discrepancy = morningStock - dailyInv.previousClosingStock; } dailyInv.morningStock = morningStock ?? dailyInv.morningStock; dailyInv.closingStock = closingStock ?? dailyInv.closingStock; dailyInv.inboundQuantity = inboundQuantity ?? dailyInv.inboundQuantity; dailyInv.outboundQuantity = outboundQuantity ?? dailyInv.outboundQuantity; dailyInv.discrepancy = discrepancy; dailyInv.discrepancyReason = discrepancyReason || dailyInv.discrepancyReason; dailyInv.notes = notes || dailyInv.notes; dailyInv.updatedAt = new Date(); if (dailyInv.status === "대기") dailyInv.status = "작성중"; await dailyInv.save(); const updated = await DailyInventory.findById(dailyInv._id) .populate("product", "productName unit") .populate("store", "storeNumber storeName"); res.json({ success: true, dailyInventory: updated }); } catch (error) { console.error("재고 수정 오류:", error); res.status(500).json({ message: "재고 수정 실패" }); } }); // ==================== 일괄 승인 요청 ==================== router.post("/submit-all/:storeId/:date", verifyToken, async (req, res) => { try { const { storeId, date } = req.params; const targetDate = new Date(date); targetDate.setHours(0, 0, 0, 0); const inventories = await DailyInventory.find({ store: storeId, date: targetDate, status: { $in: ["대기", "작성중"] } }); const invalidItems = inventories.filter(inv => Math.abs(inv.discrepancy) > 0 && !inv.discrepancyReason ); if (invalidItems.length > 0) { return res.status(400).json({ message: `${invalidItems.length}개 항목에 재고 차이 사유가 필요합니다.` }); } await DailyInventory.updateMany( { store: storeId, date: targetDate, status: { $in: ["대기", "작성중"] } }, { status: "승인요청", submittedBy: req.user._id, submittedAt: new Date() } ); res.json({ success: true, message: `${inventories.length}개 항목이 승인 요청되었습니다.` }); } catch (error) { console.error("일괄 승인 요청 오류:", error); res.status(500).json({ message: "일괄 승인 요청 실패" }); } }); // ==================== 일괄 승인/거부 ==================== router.put("/:id/approve", verifyToken, verifyAdmin, async (req, res) => { try { const dailyInv = await DailyInventory.findById(req.params.id); if (!dailyInv) return res.status(404).json({ message: "재고 항목을 찾을 수 없습니다." }); if (dailyInv.status !== "승인요청") return res.status(400).json({ message: "승인 요청 상태가 아닙니다." }); dailyInv.status = "승인"; dailyInv.approvedBy = req.user._id; dailyInv.approvedAt = new Date(); await dailyInv.save(); res.json({ success: true, message: "재고가 승인되었습니다." }); } catch (error) { console.error("재고 승인 오류:", error); res.status(500).json({ message: "재고 승인 실패" }); } }); router.put("/:id/reject", verifyToken, verifyAdmin, async (req, res) => { try { const { rejectionReason } = req.body; if (!rejectionReason) return res.status(400).json({ message: "거부 사유를 입력해주세요." }); const dailyInv = await DailyInventory.findById(req.params.id); if (!dailyInv) return res.status(404).json({ message: "재고 항목을 찾을 수 없습니다." }); if (dailyInv.status !== "승인요청") return res.status(400).json({ message: "승인 요청 상태가 아닙니다." }); dailyInv.status = "거부"; dailyInv.rejectionReason = rejectionReason; dailyInv.approvedBy = req.user._id; dailyInv.approvedAt = new Date(); await dailyInv.save(); res.json({ success: true, message: "재고가 거부되었습니다." }); } catch (error) { console.error("재고 거부 오류:", error); res.status(500).json({ message: "재고 거부 실패" }); } }); router.post("/approve-all/:storeId/:date", verifyToken, verifyAdmin, async (req, res) => { try { const { storeId, date } = req.params; const targetDate = new Date(date); targetDate.setHours(0, 0, 0, 0); const result = await DailyInventory.updateMany( { store: storeId, date: targetDate, status: "승인요청" }, { status: "승인", approvedBy: req.user._id, approvedAt: new Date() } ); res.json({ success: true, message: `${result.modifiedCount}개 항목이 승인되었습니다.` }); } catch (error) { console.error("일괄 승인 오류:", error); res.status(500).json({ message: "일괄 승인 실패" }); } }); export default router; 